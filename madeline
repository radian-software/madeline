#!/usr/bin/env python3

import abc
import os
import pathlib
import shutil
import sys
import traceback

## Logging and exit

USAGE = """\
usage: madeline --source <source> --target <target>
                (put | get) [--exclude <path>]... <path>...\
"""

def warn(message):
    print("madeline: " + message, file=sys.stderr)

def die(message):
    print("madeline: " + message, file=sys.stderr)
    sys.exit(1)

def die_with_usage():
    print(USAGE, file=sys.stderr)
    sys.exit(1)

## Path objects

class Path(abc.ABC):

    @abc.abstractmethod
    def __init__(self, *args, **kwargs):
        raise NotImplementedError

    def is_stub(self):
        try:
            return self.readlink().startswith("|madeline:")
        except OSError:
            return False

    def get_stub_type(self):
        if self.is_symlink():
            return "link"
        if self.is_dir():
            return "dir"
        if self.is_file():
            return "file"
        die("not a file, directory, or symbolic link: {}"
            .format(self))

    def is_nonstub(self):
        return (not self.is_stub() and
                (self.exists() or self.is_symlink()))

    def write_stub(self, stub_type):
        assert stub_type in ("dir", "file", "link")
        self.symlink_to("|madeline:" + stub_type)

    # Pure path operations

    @abc.abstractmethod
    def __str__(self):
        raise NotImplementedError

    @abc.abstractmethod
    def __eq__(self, other):
        raise NotImplementedError

    def __ne__(self, other):
        return not (self == other)

    @abc.abstractmethod
    def __truediv__(self, other):
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def parents(self):
        raise NotImplementedError

    @abc.abstractmethod
    def relative_to(self, other):
        raise NotImplementedError

    # Query filesystem entries

    @abc.abstractmethod
    def is_file(self):
        raise NotImplementedError

    @abc.abstractmethod
    def is_dir(self):
        raise NotImplementedError

    @abc.abstractmethod
    def is_symlink(self):
        raise NotImplementedError

    @abc.abstractmethod
    def exists(self):
        raise NotImplementedError

    @abc.abstractmethod
    def iterdir(self):
        raise NotImplementedError

    # Create filesystem entries

    @abc.abstractmethod
    def readlink(self):
        raise NotImplementedError

    @abc.abstractmethod
    def mkdir(self):
        raise NotImplementedError

    @abc.abstractmethod
    def symlink_to(self, target):
        raise NotImplementedError

    # Remove filesystem entries

    @abc.abstractmethod
    def rmdir(self):
        raise NotImplementedError

    @abc.abstractmethod
    def unlink(self):
        raise NotImplementedError

class Subpath:

    def __init__(self, pathlike):
        self.path = pathlib.PurePath(pathlike)
        if self.path.is_absolute():
            raise ValueError

    def __eq__(self, other):
        if isinstance(other, Subpath):
            return self.path == other.path
        return False

class LocalPath(Path):

    def __init__(self, pathlike):
        self.path = pathlib.Path(pathlike)
        if not self.path.is_absolute():
            raise ValueError

    def __str__(self):
        return str(self.path)

    def __eq__(self, other):
        if isinstance(other, LocalPath):
            return self.path == other.path
        return False

    def __truediv__(self, other):
        if isinstance(other, Subpath):
            return LocalPath(self.path / other.path)
        raise ValueError

    @property
    def parents(self):
        for parent in self.path.parents:
            yield LocalPath(parent)

    def relative_to(self, other):
        if isinstance(other, LocalPath):
            return Subpath(self.path.relative_to(other.path))
        raise ValueError

    def is_file(self):
        return self.path.is_file()

    def is_dir(self):
        return self.path.is_dir()

    def is_symlink(self):
        return self.path.is_symlink()

    def exists(self):
        return self.path.exists()

    def iterdir(self):
        for subdir in self.path.iterdir():
            yield LocalPath(subdir)

    def readlink(self):
        return os.readlink(self.path)

    def mkdir(self):
        self.path.mkdir()

    def symlink_to(self, target):
        self.path.symlink_to(target)

    def rmdir(self):
        self.path.rmdir()

    def unlink(self):
        self.path.unlink()

def copy_path(source_path, target_path):
    if not (isinstance(source_path, LocalPath) and
            isinstance(target_path, LocalPath)):
        raise ValueError
    shutil.copy(source_path.path, target_path.path)

## Mirroring algorithm

def mirror_subpath(source_root, target_root, path, exclude_paths,
                   recursive, with_parents, create_stub):
    exclude_paths = [path for path in exclude_paths
                     if (source_root / path).is_nonstub()]
    abs_source_path = source_root / path
    abs_target_path = target_root / path
    # Only create parent directories in the target tree if we actually
    # have something to mirror, and there *are* parent directories
    # (i.e. we're not mirroring the whole tree).
    if ((with_parents and abs_source_path.is_nonstub() and
         abs_target_path != target_root)):
        abs_target_path_parents = list(abs_target_path.parents)
        abs_target_path_parents.reverse()
        # Get list of directories from target_root down to the direct
        # parent of abs_target_path.
        target_root_idx = abs_target_path_parents.index(target_root)
        abs_target_path_parents = abs_target_path_parents[target_root_idx:]
        # Create parent directories.
        for abs_target_parent in abs_target_path_parents:
            path_parent = abs_target_parent.relative_to(target_root)
            mirror_subpath(
                source_root, target_root, path_parent, exclude_paths,
                recursive=False, with_parents=False, create_stub=True)
    if abs_source_path.is_dir():
        # If there is a file or symlink, we can't mirror a directory
        # there.
        if not abs_target_path.is_dir():
            if abs_target_path.is_nonstub():
                die("already exists and not a directory: {}"
                    .format(abs_target_path))
            # If there was previously a stub there, get rid of it.
            try:
                abs_target_path.unlink()
            except FileNotFoundError:
                pass
            abs_target_path.mkdir()
        abs_source_path_children = list(abs_source_path.iterdir())
        # We will skip creating stubs in the source directory if we
        # are just going to remove it anyway, so whether the directory
        # will be removed needs to be determined ahead of time. We
        # start by guessing that we will be able to move all of the
        # contents to the target directory only in a recursive
        # mirroring operation.
        should_delete_directory = recursive
        # However, if any subpaths of the source directory exist and
        # are excluded from mirroring, we can't move them. Therefore
        # we must leave the source directoy.
        if should_delete_directory:
            for exclude_path in exclude_paths:
                if abs_target_path in (target_root / exclude_path).parents:
                    should_delete_directory = False
        for abs_source_path_child in abs_source_path_children:
            path_child = abs_source_path_child.relative_to(source_root)
            abs_target_path_child = target_root / path_child
            # If we are mirroring only the directory and not its
            # children, or if the child is excluded, then only update
            # the stub in the target tree.
            if not recursive or path_child in exclude_paths:
                if abs_source_path_child.is_dir():
                    if abs_target_path_child.is_dir():
                        continue
                    if abs_target_path_child.is_nonstub():
                        die("already exists and not a directory: {}"
                            .format(abs_target_path_child))
                    try:
                        abs_target_path_child.unlink()
                    except FileNotFoundError:
                        pass
                    abs_target_path_child.write_stub("dir")
                elif abs_source_path_child.is_nonstub():
                    # We can't have a file or directory on both sides.
                    if abs_target_path_child.is_nonstub():
                        die("already exists: {}"
                            .format(abs_target_path_child))
                    stub_type = abs_source_path_child.get_stub_type()
                    # Remove any existing stub. The type might have
                    # changed.
                    try:
                        abs_target_path_child.unlink()
                    except FileNotFoundError:
                        pass
                    abs_target_path_child.write_stub(stub_type)
                else:
                    # There's no file or directory in the source
                    # directory, so make sure we have a stub correctly
                    # corresponding to what's in the target directory
                    # (or remove any stale stub previously created).
                    try:
                        abs_source_path_child.unlink()
                    except FileNotFoundError:
                        pass
                    if ((not should_delete_directory and
                         abs_target_path_child.is_nonstub())):
                        stub_type = abs_target_path_child.get_stub_type()
                        abs_source_path_child.write_stub(stub_type)
            else:
                # Doing a full mirror.
                mirror_subpath(
                    source_root, target_root, path_child, exclude_paths,
                    recursive=True, with_parents=False,
                    create_stub=not should_delete_directory)
        # There shouldn't be anything left in the source directory by
        # now if should_delete_directory was true.
        if should_delete_directory:
            abs_source_path.rmdir()
            if create_stub:
                abs_source_path.write_stub("dir")
    elif abs_source_path.is_nonstub():
        if abs_target_path.is_nonstub():
            die("already exists: {}".format(abs_target_path))
        stub_type = abs_source_path.get_stub_type()
        try:
            abs_target_path.unlink()
        except FileNotFoundError:
            pass
        copy_path(abs_source_path, abs_target_path)
        abs_source_path.unlink()
        if create_stub:
            abs_source_path.write_stub(stub_type)
    else:
        try:
            abs_source_path.unlink()
        except FileNotFoundError:
            pass
        if create_stub and abs_target_path.is_nonstub():
            stub_type = abs_target_path.get_stub_type()
            abs_source_path.write_stub(stub_type)

## Main logic

def resolve_in_root(source_root, target_root, paths):
    resolved_paths = []
    for path in paths:
        # Make absolute *without* resolving symlinks, because
        # otherwise we might end up with a path into some
        # |madeline:dir directory...
        path = LocalPath(os.path.abspath(path))
        try:
            subpath = path.relative_to(source_root)
        except ValueError:
            try:
                subpath = path.relative_to(target_root)
            except ValueError:
                die("path is not inside source or target root: {}"
                    .format(repr(path)))
        resolved_paths.append(subpath)
    return resolved_paths

def main(args):
    if args and args[0] in ("-h", "-?", "-help", "--help", "help"):
        print(USAGE)
        sys.exit(0)
    source_root = None
    target_root = None
    reverse = None
    dir_args = []
    path_args = []
    exclude_args = []
    while args:
        if args[0] == "--source":
            source_root = args[1]
            args = args[2:]
            continue
        if args[0] == "--target":
            target_root = args[1]
            args = args[2:]
            continue
        if args[0] == "--exclude":
            exclude_args.append(args[1])
            args = args[2:]
            continue
        if reverse is None and args[0] in ("put", "get"):
            reverse = args[0] == "get"
            args = args[1:]
            continue
        subpath = args[0]
        if args[0].endswith(os.sep):
            dir_args.append(subpath)
        else:
            path_args.append(subpath)
        args = args[1:]
        continue
    if ((source_root is None or
         target_root is None or
         reverse is None or
         (not dir_args and not path_args))):
        die_with_usage()
    try:
        os.getcwd()
    except FileNotFoundError:
        die("working directory does not exist: {}"
            .format(os.environ.get("PWD", "(unknown directory)")))
    # Make paths absolute without resolving symlinks to avoid
    # following stub symlinks.
    source_root = LocalPath(os.path.abspath(source_root))
    target_root = LocalPath(os.path.abspath(target_root))
    if ((source_root in target_root.parents or
         target_root in source_root.parents)):
        die("source and target roots are not disjoint")
    dir_subpaths = resolve_in_root(source_root, target_root, dir_args)
    subpaths = resolve_in_root(source_root, target_root, path_args)
    exclude_paths = resolve_in_root(source_root, target_root, exclude_args)
    if reverse:
        source_root, target_root = target_root, source_root
    for dir_subpath in dir_subpaths:
        mirror_subpath(source_root, target_root, dir_subpath, exclude_paths,
                       recursive=False, with_parents=True, create_stub=True)
    for subpath in subpaths:
        mirror_subpath(source_root, target_root, subpath, exclude_paths,
                       recursive=True, with_parents=True, create_stub=True)
    sys.exit(0)

if __name__ == "__main__":
    args = sys.argv[1:]
    debug = False
    if args and args[0] == "--debug":
        debug = True
        args = args[1:]
    try:
        main(args)
    except SystemExit as e:
        if debug and e.code != 0:
            traceback.print_exc()
        raise

# Local Variables:
# outline-regexp: "^##+"
# End:
